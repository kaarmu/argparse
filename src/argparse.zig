const std = @import("std");
const mem = std.mem;

//-------//
// Types //
//-------//

const Str = []const u8;
const StrZ = [:0]const u8;

const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;
const ArgIterator = std.process.ArgIterator;
const File = std.fs.File;
const FileWriter = std.fs.File.Writer;

fn FnPtrType(comptime T: type) type {
    return switch (@import("builtin").zig_backend) {
        .stage1 => T,
        else => *const T,
    };
}

//--------//
// Parser //
//--------//

pub const ParserError = error{
    NameCollision,
    OutOfArguments,
    ItemNotRecognized,
    NoSuchArgument,
};

/// Parser for command-line arguments.
///
/// Parsing strategy:
///     Assume there is a string "<pos-1> [optionals-1...] <pos-2> [optionals-2...]"
///     where "<pos-n>" matches an `Argument` with `options.action == .pos` and
///     "[optionals-n...]" represent one or more `Argument` with `options.action != .pos`.
///     Assume we also have a pool of user-defined `Argument` in `arguments`.
///
///     Note: Remember that the binary path ($0 in bash) is automatically given a positional
///     `Argument`.
///
///     The parsing is divided up into groups consisting of `needle` and `haystack` for each
///     "<pos-n> [optionals-n...]". The steps are as follows...
///
///     1) set `needle` to first available positional in `arguments`
///     2) set the slice `haystack` to all `Argument` between `needle` and the next following
///     positional.
///     3) Match and collect results from the input string into `needle`.
///     4) If next string item starts with '-' then update `needle` to matching `Argument` in
///     `haystack`
///     5) Repeat from (3) until next string item must be a positional.
///     6) Parse the next group by repeating from (1).
pub const Parser = struct {
    options: ParserOptions,
    allocator: Allocator,
    arguments: ArrayList(Argument),
    item: ?Str,

    pub const ParserOptions = struct {
        name: Str = "prog",
        fmtErrFn: ?FormatErrorFn = null,
        fmtHelpFn: ?FormatFn = null,
        fmtUsageFn: ?FormatFn = null,
    };

    /// Initialize the parser.
    /// You must supply the allocator, call `deinit` when memory should be released.
    ///
    ///     allocator - Use for instance ArenaAllocator with page allocator.
    pub fn init(allocator: Allocator, comptime options: ParserOptions) Parser {
        var parser = Parser{
            .options = options,
            .allocator = allocator,
            .arguments = ArrayList(Argument).init(allocator),
            .item = null,
        };

        parser.addArgument(.{ .name = options.name, .action = .pos }) catch unreachable;

        return parser;
    }

    /// Destroy the parser.
    /// Frees any allocated memory both in the parser and any underlying `Argument`.
    pub fn deinit(self: *Parser) void {
        for (self.arguments.items) |*arg|
            arg.deinit();
        if (self.item) |item|
            self.allocator.free(item);
        self.arguments.deinit();
    }

    /// Create a new `Argument` object.
    pub fn addArgument(self: *Parser, comptime opt: ArgumentOptions) (Allocator.Error || ParserError)!void {
        var new_arg = Argument.init(self.allocator, opt);

        for (self.arguments.items) |*arg| {
            if (new_arg.options.short) |name|
                if (arg.isMatch(name)) return ParserError.NameCollision;
            if (new_arg.options.long) |name|
                if (arg.isMatch(name)) return ParserError.NameCollision;
        }

        try self.arguments.append(new_arg);
    }

    /// Get `Argument` object from parser.
    ///
    /// Call this after parsing and then get the results through:
    /// ```
    /// const arg_field = try parser.getArgument("--field");
    /// const results = arg_field.results.items;
    /// ```
    pub fn getArgument(self: Parser, item: Str) ParserError!*Argument {
        for (self.arguments.items) |*arg| {
            if (arg.isMatch(item) or arg.isName(item))
                return arg;
        } else return ParserError.NoSuchArgument;
    }

    pub fn parseArgs(self: *Parser) !void {
        var iterator = try std.process.argsWithAllocator(self.allocator);
        defer iterator.deinit();

        if (self.options.fmtErrFn == null)
            self.options.fmtErrFn = IncludedFormat.formatErrorX1;

        if (self.options.fmtHelpFn == null)
            self.options.fmtHelpFn = IncludedFormat.formatHelpX1;

        if (self.options.fmtUsageFn == null)
            self.options.fmtUsageFn = IncludedFormat.formatUsageX1;

        try self.parse(
            @TypeOf(iterator),
            &iterator,
            std.io.getStdOut().writer(),
            std.io.getStdErr().writer(),
        );
    }

    /// Parse arguments generated by iterator.
    pub fn parse(
        self: *Parser,
        comptime T: type,
        iterator: *T,
        stdout_writer: FileWriter,
        stderr_writer: FileWriter,
    ) !void {
        if (self.options.fmtHelpFn != null)
            try self.addArgument(.{
                .short = "h",
                .long = "help",
                .action = .store_true,
                .location = .loose,
            });

        var group = Group.init(self.arguments.items);
        var maybe_error: ?(ParserError || ArgumentError || Allocator.Error || FileWriter.Error) = null;

        while (true) {

            // ?[:0]T -> ?[]T
            self.item = if (iterator.next()) |item| item[0..] else null;

            if (self.item) |item| {
                if (item[0] == '-') {
                    // we search for a new needle matching in name among haystack
                    group.needle = for (group.haystack) |*arg| {
                        if (arg.state == .full) continue;
                        if (!arg.isMatch(item)) continue;
                        break arg;
                    } else for (group.all) |*arg| {
                        if (arg.options.location != .loose) continue;
                        if (arg.state == .full) continue;
                        if (!arg.isMatch(item)) continue;
                        break arg;
                    } else {
                        maybe_error = ParserError.ItemNotRecognized;
                        break; // End: parsing error
                    };
                    try group.needle.found(item);
                } else if (0 < group.needle.capacity()) {
                    // needle can be any action
                    if (group.needle.state == .unfound)
                        try group.needle.found(item)
                    else
                        try group.needle.addResult(item);
                } else if (group.update()) {
                    // needle is guaranteed to be .pos
                    try group.needle.found(item);
                } else break; // End: success
            } else break; // End: success
        }

        if (maybe_error == null) {
            for (self.arguments.items) |*arg|
                arg.finally() catch |err| {
                    maybe_error = err;
                };
        }

        if (maybe_error) |err| {
            for (@typeInfo(ParserError || ArgumentError).ErrorSet.?) |ref_err| {
                if (std.mem.eql(u8, ref_err.name, @errorName(err)))
                    if (self.options.fmtErrFn) |fmtErrFn| {
                        try fmtErrFn(.{
                            .parser = self,
                            .writer = stderr_writer,
                            .argument = group.needle,
                            .err = @errSetCast((ParserError || ArgumentError), err),
                        });
                        break;
                    };
            } else return err;
        }

        if (self.options.fmtHelpFn) |fmtHelpFn| {
            const arg_help = try self.getArgument("--help");
            if (arg_help.getResult(.{ .Type = bool }))
                try fmtHelpFn(.{ .parser = self, .writer = stdout_writer })
            else |_|
                unreachable;
        }
    }
};

pub const Group = struct {
    all: []Argument,
    needle: *Argument,
    haystack: []Argument,

    pub fn init(all: []Argument) Group {
        return Group{
            .all = all,
            .needle = &all[0],
            .haystack = for (all[1..]) |*arg, i| {
                if (arg.options.action == .pos) break all[1..i];
            } else all[1..],
        };
    }

    pub fn reset(self: *Group) void {
        self.needle = &self.all[0];
        self.haystack = self.all[1..];
        for (self.haystack) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack.len = i;
            break;
        }
    }

    /// Move needle and haystack to the following group
    pub fn next(self: *Group) bool {
        // find needle index
        const index = for (self.all) |*arg, i| {
            if (arg == self.needle) break i;
        } else {
            return false;
        };

        // set needle to the first .unfound .pos it can find
        for (self.all[index + 1 ..]) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack = self.all[i + 1 ..];
            self.needle = arg;
            break;
        } else return false;

        // set the haystack to all between the needle and the following .unfound .pos
        for (self.haystack) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack.len = i;
            break;
        }

        return true;
    }

    /// Update needle and haystack to first .unfound .pos (can yield the same group).
    pub fn update(self: *Group) bool {
        // set needle to the first .unfound .pos it can find
        for (self.all) |*arg, i| {
            if (arg.options.action != .pos) continue;
            if (arg.state != .unfound) continue;

            self.haystack = self.all[i + 1 ..];
            self.needle = arg;
            break;
        } else return false;

        // set the haystack to all between the needle and the following .unfound .pos
        for (self.haystack) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack.len = i;
            break;
        }

        return true;
    }
};

//----------//
// Argument //
//----------//

const TRUE = "TRUE";
const FALSE = "FALSE";

pub const ArgumentError = error{
    NotValidChoice,
    AlreadyFull,
    MissingResults,
    ArgCannotExtend,
    CompletionFailed,
};

pub const ArgumentOptions = struct {

    /// Argument behaviour.
    /// Arguments is always associated with an action. The action specifies
    /// how items (string input by user) are collected and handled by the
    /// `Argument` object.
    pub const Action = enum {
        /// Positional arguments.
        /// Usage:
        ///     exe a1 a2 a3 ... => [a1, a2, a3]
        /// Options:
        ///     nargs
        ///     required
        ///     choices
        pos,

        /// Traditional flag/option-like arguments.
        /// Usage:
        ///     exe -f a1 a2 ... aN => [a1, a2, ..., aN]
        /// Options:
        ///     nargs
        ///     extend
        ///     required
        ///     choices
        store,

        /// Store a specific constant.
        /// Usage:
        ///     exe -f => [c]
        /// Options:
        ///     extend
        store_const,

        /// Special case of `store_const` where result is true when argument is present.
        /// Usage:
        ///     exe -f => [1]
        store_true,

        /// Special case of `store_const` where result is false when argument is present.
        /// Usage:
        ///     exe -f => [0]
        store_false,

        // /// exe -fN
        // /// [N]
        // number,

        // /// exe -f -f -f
        // /// [3]
        // count,

        // /// exe a1 a2 P a3 a4 ...
        // /// parser(P, a3 a4 ...)
        // subparser,
    };

    //------------------//
    // Argument Options //
    //------------------//

    /// Generic name. Is not used to match the argument.
    name: ?Str = null,

    /// Short name of flag or option.
    short: ?Str = null,

    /// Long name of flag or option.
    long: ?Str = null,

    /// The type/behaviour of the argument.
    action: Action = .store,

    /// Number of arguments the argument can take.
    /// Can be supplied the following special case values:
    ///     '?' => One or none
    ///     '*' => None or many
    ///     '+' => One or many
    nargs: u8 = 1,

    /// Extendable/appendable argument. Can only be used with `action=.store` and `nargs>2`.
    extend: bool = false,

    /// The constant value for `store_const`. If the argument is present, this value will be the result.
    constant: ?Str = null,

    /// A default value for in case the argument is not present.
    default: ?Str = null,

    /// Require the argument to be present.
    required: bool = false,

    /// Limit what the result value can be. If the `choices` list is not empty, a value can then be
    /// accepted if it is found in the list.
    choices: ?[]Str = null,

    /// Can the argument be found only in the group it was defined, i.e. order-sensitive (.strict),
    /// or can it be found anywhere (.loose).
    location: enum { strict, loose } = .strict,

    /// A descriptive help message for the argument.
    help: ?Str = null,

    pub fn checkValidity(comptime self: ArgumentOptions) void {
        // action and names
        if (self.action == .pos and self.name == null)
            @compileError("Missing identifier - action `.pos` must have a `name`");
        if (self.action != .pos and self.short == null and self.long == null)
            @compileError("Missing identifier - action \"" ++ @tagName(self.action) ++ "\" must have either a `short` or `long` name");

        // names must have length
        if (self.name != null and self.name.?.len == 0)
            @compileError("Invalid identifier - `name` must be `null` of non-empty");
        if (self.short != null and self.short.?.len == 0)
            @compileError("Invalid identifier - `short` must be `null` of non-empty");
        if (self.long != null and self.long.?.len == 0)
            @compileError("Invalid identifier - `long` must be `null` of non-empty");

        // names and dashes
        if (self.short != null and self.short.?[0] == '-')
            @compileError("Invalid identifier - \"" ++ self.short.? ++ "\" dashes are inserted by the parser");
        if (self.long != null and self.long.?[0] == '-')
            @compileError("Invalid identifier - \"" ++ self.long.? ++ "\" dashes are inserted by the parser");

        // nargs
        if (self.nargs <= 0)
            @compileError("Invalid number of args - `nargs` must be greater than 0");
        if (self.required and self.nargs == '*')
            @compileError("Contradicting options - `nargs='*'` allows returning with `.empty` state while `required` does not");
        if (self.required and self.nargs == '?')
            @compileError("Contradicting options - `nargs='*'` allows returning with `.empty` state while `required` does not");

        // default
        if (self.required and self.default != null)
            @compileError("Contradicting options - `default` is used when returning with `.empty` state which is not allowed while `required`");
        if (self.nargs == '+' and self.default != null)
            @compileError("Contradicting options - `default` is used when returning with `.empty` state which is not allowed with `nargs='+'`");

        // constant
        if (self.action == .store and self.constant != null)
            @compileError("Contradicting options - action `store` picks up user-supplied values, not `constant`");
        if (self.action == .store_const and self.constant == null)
            @compileError("Must have constant - `constant` value must exist for action `.store_const`");
        if (self.action == .store_const and self.nargs > 1 and !self.extend)
            @compileError("Contradicting options - multiple `constant` must have `extend` enabled");

        // extend
        if (self.extend and self.action != .store)
            @compileError("Invalid combination - argument can `extend` only if also having action `.store`");
        if (self.extend and (self.nargs == '?' or self.nargs < 2))
            @compileError("Invalid combination - argument can `extend` if there is room for only one value.");

        // choices
        if (self.choices) |choices| {
            if (self.constant) |val| for (choices) |item| {
                if (item == val) break;
            } else @compileError("Constant not in choices - if `constant` is given it must comply with `choices`");

            if (self.default) |val| for (choices) |item| {
                if (item == val) break;
            } else @compileError("Default not in choices - if `default` is given it must comply with `choices`");
        }

        // location
        if (self.location == .loose and self.action == .pos)
            @compileError("Invalid combination - positional arguments must have `.strict` location.");
    }
};

pub const Argument = struct {
    const State = enum {
        unfound,
        empty,
        partial,
        full,
    };

    options: ArgumentOptions,
    allocator: Allocator,
    results: std.ArrayList(Str),
    state: State,

    pub fn init(allocator: Allocator, comptime opt: ArgumentOptions) Argument {
        opt.checkValidity();

        var self = Argument{
            .options = opt,
            .allocator = allocator,
            .results = std.ArrayList(Str).init(allocator),
            .state = .unfound,
        };

        if (self.options.nargs == '+')
            self.options.required = true;

        if (self.options.action == .store_true) {
            self.options.action = .store_const;
            self.options.constant = TRUE;
            self.options.default = FALSE;
        }

        if (self.options.action == .store_false) {
            self.options.action = .store_const;
            self.options.constant = TRUE;
            self.options.default = FALSE;
        }

        return self;
    }

    pub fn deinit(self: *Argument) void {
        for (self.results.items) |str|
            self.allocator.free(str);
        self.results.deinit();
    }

    pub fn isName(self: *Argument, item: Str) bool {
        var eql_cond: bool = false;
        if (self.options.name) |name|
            eql_cond = eql_cond or std.mem.eql(u8, item, name);
        if (self.options.short) |name|
            eql_cond = eql_cond or std.mem.eql(u8, item, name);
        if (self.options.long) |name|
            eql_cond = eql_cond or std.mem.eql(u8, item, name);
        return eql_cond;
    }

    pub fn isMatch(self: *Argument, item: Str) bool {
        if (std.mem.startsWith(u8, item, "--"))
            return if (self.options.long) |name| std.mem.eql(u8, name, item[2..]) else false;
        if (std.mem.startsWith(u8, item, "-"))
            return if (self.options.short) |name| std.mem.eql(u8, name, item[1..]) else false;
        return false;
    }

    pub fn isPartialLong(self: *Argument, item: Str) bool {
        return if (self.options.long) |name|
            std.mem.startsWith(u8, item, "--") and std.mem.startsWith(u8, name, item[2..])
        else
            false;
    }

    pub fn isPartialShort(self: *Argument, item: Str) bool {
        return if (self.options.short) |name|
            std.mem.startsWith(u8, item, "-") and std.mem.startsWith(u8, name, item[1..])
        else
            false;
    }

    pub fn found(self: *Argument, item: Str) (Allocator.Error || ArgumentError)!void {
        if (self.state == .unfound)
            self.state = .empty
        else if (!self.options.extend)
            return ArgumentError.ArgCannotExtend;

        switch (self.options.action) {
            .pos => try self.addResult(item),
            .store_const => try self.dupeAndAdd(self.options.constant.?),
            else => {},
        }
    }

    pub fn capacity(self: *Argument) usize {
        return switch (self.options.nargs) {
            '*', '+' => |n| n,
            '?' => 1 - self.results.items.len,
            else => |n| n - self.results.items.len,
        };
    }

    fn dupeAndAdd(self: *Argument, item: Str) (Allocator.Error || ArgumentError)!void {
        var copy = try self.allocator.dupe(u8, item);
        try self.addResult(copy);
    }

    // NOTE: Takes ownership of `item`.
    pub fn addResult(self: *Argument, item: Str) (Allocator.Error || ArgumentError)!void {
        self.state = switch (self.state) {
            .unfound => unreachable,
            .empty, .partial => switch (self.options.nargs) {
                '*', '+' => State.partial,
                '?' => State.full,
                else => |n| if (self.results.items.len + 1 < n) State.partial else State.full,
            },
            .full => return ArgumentError.AlreadyFull,
        };

        if (self.options.choices) |choices| for (choices) |choice| {
            if (std.mem.eql(u8, item, choice))
                break;
        } else return ArgumentError.NotValidChoice;

        try self.results.append(item);
    }

    pub fn finally(self: *Argument) (Allocator.Error || ArgumentError)!void {
        switch (self.state) {
            .unfound => if (self.options.default) |val| {
                self.state = .empty;
                try self.dupeAndAdd(val);
                try self.finally();
            },
            // .empty if e.g. `action=.store` and `nargs='*'` with flag present but no arguments.
            // .empty does not get default value, default value is only given if unfound.
            .empty => switch (self.options.nargs) {
                '*', '?' => {},
                '+' => return ArgumentError.MissingResults,
                else => return ArgumentError.MissingResults,
            },
            .partial => switch (self.options.nargs) {
                '*', '?', '+' => {},
                else => |n| {
                    if (self.results.items.len < n)
                        return ArgumentError.MissingResults;
                },
            },
            .full => {},
        }
    }

    const GetResultOptions = struct {
        Type: type = Str,
        index: usize = 0,
    };

    const GetResultErrors = error{
        IndexOutOfBounds,
        NotBoolean,
    };

    /// Get a result from the parser.
    pub fn getResult(self: *Argument, comptime opt: GetResultOptions) !opt.Type {
        switch (self.options.nargs) {
            '*' => {},
            '?' => if (1 < opt.index) return GetResultErrors.IndexOutOfBounds,
            '+' => if (opt.index == 0) return GetResultErrors.IndexOutOfBounds,
            else => |n| if (n <= opt.index) return GetResultErrors.IndexOutOfBounds,
        }
        if (self.results.items.len <= opt.index)
            return GetResultErrors.IndexOutOfBounds;

        switch (@typeInfo(opt.Type)) {
            .Int => |t| switch (t.signedness) {
                .signed => try std.fmt.parseInt(opt.Type, self.results.items[opt.index], 0),
                .unsigned => try std.fmt.parseUnsigned(opt.Type, self.results.items[opt.index], 0),
            },
            .Bool => {
                if (self.results.items[opt.index].len == TRUE.len)
                    for (self.results.items[opt.index]) |c, i| {
                        if (std.ascii.toUpper(c) != TRUE[i]) break;
                    } else return true;

                if (self.results.items[opt.index].len == FALSE.len)
                    for (self.results.items[opt.index]) |c, i| {
                        if (std.ascii.toUpper(c) != FALSE[i]) break;
                    } else return false;

                return GetResultErrors.NotBoolean;
            },
            .Pointer => |t| {
                if (t.size != .Slice) @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
                if (t.child != u8) @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
                if (!t.is_const) @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
                return if (t.sentinel == null)
                    self.results.items[opt.index]
                else if (t.sentinel == 0)
                    self.results.items[opt.index][0.. :0]
                else
                    @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
            },
            else => @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\"."),
        }
    }
};

//------------//
// Completion //
//------------//

/// Completion algorithm for bash.
///
/// Environment variables:
///     COMP_LINE   The current command line.
///     COMP_TYPE   Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called. See switch statement below.
///     COMP_POINT  The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to ${#COMP_LINE}.
///     COMP_KEY    The key (or final key of a key sequence) used to invoke the current completion function.
pub const BashCompletion = struct {
    const CompletionFn = FnPtrType(fn (*Parser, FileWriter, u8, Str) FileWriter.Error!void);

    normalFn: CompletionFn = Included.normalX1,
    successiveFn: CompletionFn = Included.successiveX1,
    alternativesFn: CompletionFn = Included.invalid,
    unmodifiedFn: CompletionFn = Included.invalid,
    menuFn: CompletionFn = Included.invalid,
    invalidFn: CompletionFn = Included.invalid,

    pub fn complete(self: BashCompletion, parser: *Parser) !void {
        const writer = std.io.getStdOut().writer();

        const env_comp_line: Str = std.os.getenv("COMP_LINE") orelse return;
        const env_comp_type: Str = std.os.getenv("COMP_TYPE") orelse return;
        // const env_comp_point: Str = std.os.getenv("COMP_POINT") orelse return;
        // const env_comp_key: Str = std.os.getenv("COMP_KEY") orelse return;

        const comp_type = try std.fmt.parseUnsigned(u8, env_comp_type, 10);

        // TAB, for normal completion
        // ‘?’, for listing completions after successive tabs
        // ‘!’, for listing alternatives on partial word completion
        // ‘@’, to list completions if the word is not unmodified
        // ‘%’, for menu completion
        switch (comp_type) {
            '\t' => try self.normalFn(parser, writer, comp_type, env_comp_line),
            '?' => try self.successiveFn(parser, writer, comp_type, env_comp_line),
            '!' => try self.alternativesFn(parser, writer, comp_type, env_comp_line),
            '@' => try self.unmodifiedFn(parser, writer, comp_type, env_comp_line),
            '%' => try self.menuFn(parser, writer, comp_type, env_comp_line),
            else => try self.invalidFn(parser, writer, comp_type, env_comp_line),
        }
    }

    const Included = struct {
        pub fn invalid(
            _: *Parser,
            _: FileWriter,
            comp_type: u8,
            _: Str,
        ) FileWriter.Error!void {
            std.log.err("Invalid completion - COMP_TYPE='{c}'", .{comp_type});
        }

        pub fn normalX1(
            parser: *Parser,
            writer: FileWriter,
            _: u8,
            comp_line: Str,
        ) FileWriter.Error!void {
            var word_iter = std.mem.tokenize(u8, comp_line, " ");
            var last_word: Str = undefined;
            while (word_iter.next()) |word|
                last_word = word;

            for (parser.arguments.items) |*arg|
                if (arg.isMatch(last_word)) {
                    continue; // do not list if exactly equal
                } else if (std.mem.eql(u8, "-", last_word)) {
                    if (arg.options.short) |name| try writer.print("-{s}\n", .{name});
                    if (arg.options.long) |name| try writer.print("--{s}\n", .{name});
                } else if (arg.isPartialShort(last_word)) {
                    try writer.print("-{s}\n", .{arg.options.short.?});
                } else if (arg.isPartialLong(last_word)) {
                    try writer.print("--{s}\n", .{arg.options.long.?});
                };
        }

        pub fn successiveX1(
            parser: *Parser,
            writer: FileWriter,
            _: u8,
            _: Str,
        ) FileWriter.Error!void {
            for (parser.arguments.items) |*arg|
                if (arg.options.short != null and arg.options.long != null) {
                    try writer.print("-{s}, --{s}\n", .{ arg.options.short.?, arg.options.long.? });
                } else if (arg.options.short) |name| {
                    try writer.print("-{s}       \n", .{name});
                } else if (arg.options.long) |name| {
                    try writer.print("      --{s}\n", .{name});
                };
        }
    };
};

//-----------------//
// Print utilities //
//-----------------//

pub const FormatOptions = struct {
    parser: *Parser,
    writer: FileWriter,
};

pub const FormatFn = FnPtrType(fn (FormatOptions) FileWriter.Error!void);

pub const FormatErrorOptions = struct {
    parser: *Parser,
    writer: FileWriter,
    argument: *Argument,
    err: (ParserError || ArgumentError),
};

pub const FormatErrorFn = FnPtrType(fn (FormatErrorOptions) FileWriter.Error!void);

pub const IncludedFormat = struct {
    pub fn formatUsageX1(opt: FormatOptions) FileWriter.Error!void {
        var group = Group.init(opt.parser.arguments.items);
        const show_numbers = blk: {
            var i: u8 = 1;
            while (group.next()) i += 1;
            break :blk 1 < i;
        };

        try opt.writer.writeAll("Usage: ");

        group.reset();
        var grp_i: u8 = 1;
        try opt.writer.writeAll(group.needle.options.name.?);

        if (group.haystack.len > 0) {
            if (show_numbers)
                try opt.writer.print(" [OPTIONS {u}]", .{grp_i})
            else
                try opt.writer.writeAll(" [OPTIONS]");
        }

        while (group.next()) {
            for (group.needle.options.name.?) |c|
                try opt.writer.writeByte(std.ascii.toUpper(c));

            if (group.haystack.len > 0) {
                if (show_numbers)
                    try opt.writer.print(" [OPTIONS {u}]", .{grp_i})
                else
                    try opt.writer.writeAll(" [OPTIONS]");
            }
        }

        try opt.writer.writeByte('\n');
    }

    pub fn formatHelpX1(opt: FormatOptions) FileWriter.Error!void {
        if (opt.parser.options.fmtUsageFn) |fmtUsage|
            try fmtUsage(opt);

        var group = Group.init(opt.parser.arguments.items);
        const show_numbers = blk: {
            var i: u8 = 1;
            while (group.next()) i += 1;
            break :blk 1 < i;
        };

        group.reset();
        var is_new_group = true;
        var grp_i: u8 = 1;
        var col2_i: usize = 2;
        var col3_i: usize = 2;
        var str_i: usize = undefined;
        const col23_margin = 6;
        const window_width = 80;

        // General options

        for (opt.parser.arguments.items) |*arg| if (arg.options.location == .loose) {
            if (arg.options.short) |name|
                col2_i = std.math.max(
                    col2_i,
                    2 + 1 + name.len + 2,
                );
            if (arg.options.long) |name|
                col3_i = std.math.max(
                    col3_i,
                    col2_i + 2 + name.len + col23_margin,
                );
        };

        for (opt.parser.arguments.items) |*arg| if (arg.options.location == .loose) {
            if (is_new_group) {
                try opt.writer.print("\nGENERAL OPTIONS:", .{});
                is_new_group = false;
            }

            try opt.writer.writeByte('\n');
            str_i = 0;

            if (arg.options.short) |name| {
                try opt.writer.print("  -{s}", .{name});
                try opt.writer.writeByte(if (arg.options.long != null) ',' else ' ');
                str_i += 4 + name.len;
            }
            try opt.writer.writeByteNTimes(' ', col2_i - str_i);
            str_i += col2_i - str_i;

            if (arg.options.long) |name| {
                try opt.writer.print("--{s}", .{name});
                str_i += 2 + name.len;
            }
            try opt.writer.writeByteNTimes(' ', col3_i - str_i);
            str_i += col3_i - str_i;

            if (arg.options.help) |help| {
                var help_tokens = std.mem.tokenize(u8, help, " ");
                if (help_tokens.next()) |token| {
                    try opt.writer.writeAll(token);
                    str_i += token.len;
                }
                while (help_tokens.next()) |token|
                    if (window_width < str_i + 1 + token.len) {
                        try opt.writer.writeByte('\n');
                        try opt.writer.writeByteNTimes(' ', col3_i);
                        str_i = col3_i;
                        try opt.writer.writeAll(token);
                        str_i += token.len;
                    } else {
                        try opt.writer.writeByte(' ');
                        try opt.writer.writeAll(token);
                        str_i += 1 + token.len;
                    };
            }
        };

        // accidental condition for 'have general options been printed'
        if (!is_new_group)
            try opt.writer.writeByte('\n');

        // other options

        while (true) {
            is_new_group = true;
            col2_i = 2;
            col3_i = 2;

            for (group.haystack) |*arg| if (arg.options.location == .strict) {
                if (arg.options.short) |name|
                    col2_i = std.math.max(
                        col2_i,
                        2 + 1 + name.len + 2,
                    );
                if (arg.options.long) |name|
                    col3_i = std.math.max(
                        col3_i,
                        col2_i + 2 + name.len + col23_margin,
                    );
            };

            for (group.haystack) |*arg| if (arg.options.location == .strict) {
                if (is_new_group) {
                    if (show_numbers)
                        try opt.writer.print("\nOPTIONS ({u}):", .{grp_i})
                    else
                        try opt.writer.print("\nOPTIONS:", .{});
                    is_new_group = false;
                }

                try opt.writer.writeByte('\n');
                str_i = 0;

                if (arg.options.short) |name| {
                    try opt.writer.print("  -{s}", .{name});
                    try opt.writer.writeByte(if (arg.options.long != null) ',' else ' ');
                    str_i += 4 + name.len;
                }
                try opt.writer.writeByteNTimes(' ', col2_i - str_i);
                str_i += col2_i - str_i;

                if (arg.options.long) |name| {
                    try opt.writer.print("--{s}", .{name});
                    str_i += 2 + name.len;
                }
                try opt.writer.writeByteNTimes(' ', col3_i - str_i);
                str_i += col3_i - str_i;

                if (arg.options.help) |help| {
                    var help_tokens = std.mem.tokenize(u8, help, " ");
                    if (help_tokens.next()) |token| {
                        try opt.writer.writeAll(token);
                        str_i += token.len;
                    }
                    while (help_tokens.next()) |token|
                        if (window_width < str_i + 1 + token.len) {
                            try opt.writer.writeByte('\n');
                            try opt.writer.writeByteNTimes(' ', col3_i);
                            str_i = col3_i;
                            try opt.writer.writeAll(token);
                            str_i += token.len;
                        } else {
                            try opt.writer.writeByte(' ');
                            try opt.writer.writeAll(token);
                            str_i += 1 + token.len;
                        };
                }
            };

            try opt.writer.writeByte('\n');
            if (group.next()) grp_i += 1 else break;
        }
    }

    pub fn formatErrorX1(opt: FormatErrorOptions) FileWriter.Error!void {
        switch (opt.err) {
            // ParserError.NameCollision => {},
            // ParserError.OutOfArguments => {},
            ParserError.ItemNotRecognized => {
                try opt.writer.print("error({s}): Item \"{s}\" not recognized.\n", .{ @errorName(opt.err), opt.parser.item });
            },
            // ParserError.NoSuchArgument => {},
            // ParserError.NotValidChoice => {},
            // ArgumentError.AlreadyFull => {},
            ArgumentError.MissingResults => {
                if (opt.argument.options.name) |name|
                    try opt.writer.print("error({s}): Missing input, item=\"{s}\"\n", .{ @errorName(opt.err), name })
                else if (opt.argument.options.long) |name|
                    try opt.writer.print("error({s}): Missing input, item=\"--{s}\"\n", .{ @errorName(opt.err), name })
                else if (opt.argument.options.short) |name|
                    try opt.writer.print("error({s}): Missing input, item=\"-{s}\"\n", .{ @errorName(opt.err), name });
            },
            // ArgumentError.ArgCannotExtend => {},
            // ArgumentError.CompletionFailed => {},
            else => @panic("Not implemented message for current error"),
        }
    }
};

//--------------------//
// Iterator Utilities //
//--------------------//

fn SliceIterator(comptime T: type) type {
    return struct {
        index: usize,
        slice: []const T,

        const Self = @This();

        pub fn init(slice: []const T) Self {
            return Self{ .index = 0, .slice = slice };
        }

        pub fn next(self: *Self) ?T {
            if (self.slice.len <= self.index)
                return null;
            defer self.index += 1;
            return self.slice[self.index];
        }
    };
}

pub fn ArgvIterator(comptime argv: anytype) type {
    const ArgvType = @TypeOf(argv);
    const argv_fields = std.meta.fields(ArgvType);

    if (@typeInfo(ArgvType) != .Struct)
        @compileError("Expected tuple argument, found " ++ @typeName(ArgvType));

    comptime var arr: [argv_fields.len]StrZ = undefined;
    inline for (argv_fields) |field, i|
        arr[i] = @field(argv, field.name);

    return struct {
        index: usize,
        argv: [arr.len]StrZ,

        pub const Self = @This();

        pub fn init() Self {
            return Self{ .index = 0, .argv = argv };
        }

        pub fn next(self: *Self, allocator: std.mem.Allocator) !?StrZ {
            if (self.index < self.argv.len) {
                defer self.index += 1;
                return try allocator.dupeZ(u8, self.argv[self.index]);
            } else return null;
        }
    };
}
