const std = @import("std");
const mem = std.mem;

//-------//
// Types //
//-------//

const Str = []const u8;
const StrZ = [:0]const u8;

const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;
const ArgIterator = std.process.ArgIterator;
const File = std.fs.File;
const FileWriter = std.fs.File.Writer;

//--------//
// Parser //
//--------//

pub const ParserError = error{
    NameCollision,
    OutOfArguments,
    ItemNotRecognized,
    NoSuchArgument,
};

/// Parser for command-line arguments.
///
/// Parsing strategy:
///     Assume there is a string "<pos-1> [optionals-1...] <pos-2> [optionals-2...]"
///     where "<pos-n>" matches an `Argument` with `options.action == .pos` and
///     "[optionals-n...]" represent one or more `Argument` with `options.action != .pos`.
///     Assume we also have a pool of user-defined `Argument` in `arguments`.
///
///     Note: Remember that the binary path ($0 in bash) is automatically given a positional
///     `Argument`.
///
///     The parsing is divided up into groups consisting of `needle` and `haystack` for each
///     "<pos-n> [optionals-n...]". The steps are as follows...
///
///     1) set `needle` to first available positional in `arguments`
///     2) set the slice `haystack` to all `Argument` between `needle` and the next following
///     positional.
///     3) Match and collect results from the input string into `needle`.
///     4) If next string item starts with '-' then update `needle` to matching `Argument` in
///     `haystack`
///     5) Repeat from (3) until next string item must be a positional.
///     6) Parse the next group by repeating from (1).
pub const Parser = struct {
    options: ParserOptions,
    allocator: Allocator,
    arguments: ArrayList(Argument),
    item: ?Str,

    pub const ParserOptions = struct {
        name: Str = "prog",
        fmtErrFn: ?FormatErrorFn = null,
        fmtHelpFn: ?FormatHelpFn = null,
        fmtUsageFn: ?FormatUsageFn = null,
    };

    /// Initialize the parser.
    /// You must supply the allocator, call `deinit` when memory should be released.
    ///
    ///     allocator - Use for instance ArenaAllocator with page allocator.
    pub fn init(allocator: Allocator, comptime options: ParserOptions) Parser {
        var parser = Parser{
            .options = options,
            .allocator = allocator,
            .arguments = ArrayList(Argument).init(allocator),
            .item = null,
        };

        parser.addArgument(.{ .name = options.name, .action = .pos }) catch unreachable;

        return parser;
    }

    /// Destroy the parser.
    /// Frees any allocated memory both in the parser and any underlying `Argument`.
    pub fn deinit(self: *Parser) void {
        for (self.arguments.items) |*arg|
            arg.deinit();
        if (self.item) |item|
            self.allocator.free(item);
        self.arguments.deinit();
    }

    /// Create a new `Argument` object.
    pub fn addArgument(self: *Parser, comptime opt: ArgumentOptions) (Allocator.Error || ParserError)!void {
        var new_arg = Argument.init(self.allocator, opt);

        for (self.arguments.items) |*arg| {
            if (new_arg.options.short) |name|
                if (arg.isMatch(name)) return ParserError.NameCollision;
            if (new_arg.options.long) |name|
                if (arg.isMatch(name)) return ParserError.NameCollision;
        }

        try self.arguments.append(new_arg);
    }

    /// Get `Argument` object from parser.
    ///
    /// Call this after parsing and then get the results through:
    /// ```
    /// const arg_field = try parser.getArgument("--field");
    /// const results = arg_field.results.items;
    /// ```
    pub fn getArgument(self: Parser, item: Str) ParserError!*Argument {
        for (self.arguments.items) |*arg| {
            if (arg.isMatch(item) or arg.isName(item))
                return arg;
        } else return ParserError.NoSuchArgument;
    }

    pub fn parseArgs(self: *Parser) !void {
        var iterator = try std.process.argsWithAllocator(self.allocator);
        defer iterator.deinit();

        if (self.options.fmtErrFn == null)
            self.options.fmtErrFn = formatErrorX1;

        if (self.options.fmtHelpFn == null)
            self.options.fmtHelpFn = formatHelpX1;

        if (self.options.fmtUsageFn == null)
            self.options.fmtUsageFn = formatUsageX1;

        try self.parse(
            @TypeOf(iterator),
            &iterator,
            std.io.getStdOut().writer(),
            std.io.getStdErr().writer(),
        );
    }

    /// Parse arguments generated by iterator.
    pub fn parse(
        self: *Parser,
        comptime T: type,
        iterator: *T,
        stdout_writer: FileWriter,
        stderr_writer: FileWriter,
    ) !void {
        if (self.options.fmtHelpFn != null)
            try self.addArgument(.{
                .short = "h",
                .long = "help",
                .action = .store_true,
                .location = .loose,
            });

        var group = Group.init(self.arguments.items);

        var parsing_error: ?(ParserError || ArgumentError) = while (group.ready) {

            // ?[:0]T -> ?[]T
            self.item = if (iterator.next()) |item| item[0..] else null;

            if (self.item) |item| {
                if (item[0] == '-') {
                    group.needle = for (group.haystack) |*arg| {
                        if (arg.state == .full) continue;
                        if (!arg.isMatch(item)) continue;
                        break arg;
                    } else for (group.all) |*arg| {
                        if (arg.options.location != .loose) continue;
                        if (arg.state == .full) continue;
                        if (!arg.isMatch(item)) continue;
                        break arg;
                    } else {
                        group.ready = false;
                        break ParserError.ItemNotRecognized;
                    };
                    try group.needle.found(item);
                } else if (0 < group.needle.capacity()) {
                    if (group.needle.state == .unfound)
                        try group.needle.found(item)
                    else
                        try group.needle.addResult(item);
                } else {
                    group.update();
                    if (group.ready) try group.needle.found(item);
                }
            } else group.ready = false;
        } else null;

        if (parsing_error) |err| {
            if (self.options.fmtErrFn) |fmtErrFn|
                try fmtErrFn(
                    self,
                    @errSetCast((ParserError || ArgumentError), err),
                    stderr_writer,
                )
            else
                return err;
        }

        for (self.arguments.items) |*arg|
            arg.finally() catch |err| {
                if (@TypeOf(err) == Allocator.Error)
                    return err;
                if (self.options.fmtErrFn) |fmtErrFn|
                    try fmtErrFn(
                        self,
                        @errSetCast((ParserError || ArgumentError), err),
                        stderr_writer,
                    )
                else
                    return err;
            };

        if (self.options.fmtHelpFn) |fmtHelpFn| {
            const arg_help = try self.getArgument("--help");
            if (arg_help.getResult(.{ .Type = bool }))
                try fmtHelpFn(self, stdout_writer)
            else |_|
                unreachable;
        }
    }
};

pub const Group = struct {
    all: []Argument,
    ready: bool,
    needle: *Argument,
    haystack: []Argument,

    pub fn init(all: []Argument) Group {
        return Group{
            .all = all,
            .ready = true,
            .needle = &all[0],
            .haystack = for (all[1..]) |*arg, i| {
                if (arg.options.action == .pos) break all[1..i];
            } else all[1..],
        };
    }

    pub fn reset(self: *Group) void {
        self.ready = true;
        self.needle = &self.all[0];
        self.haystack = self.all[1..];
        for (self.haystack) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack.len = i;
            break;
        }
    }

    /// Move needle and haystack to the following group
    pub fn next(self: *Group) void {
        // find needle index
        const index = for (self.all) |*arg, i| {
            if (arg == self.needle) break i;
        } else {
            self.ready = false;
            return;
        };

        // set needle to the first .unfound .pos it can find
        for (self.all[index + 1 ..]) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack = self.all[i + 1 ..];
            self.needle = arg;
            break;
        } else self.ready = false;

        // set the haystack to all between the needle and the following .unfound .pos
        for (self.haystack) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack.len = i;
            break;
        }
    }

    /// Update needle and haystack to first .unfound .pos (can yield the same group).
    pub fn update(self: *Group) void {
        // set needle to the first .unfound .pos it can find
        for (self.all) |*arg, i| {
            if (arg.options.action != .pos) continue;
            if (arg.state != .unfound) continue;

            self.haystack = self.all[i + 1 ..];
            self.needle = arg;
            break;
        } else self.ready = false;

        // set the haystack to all between the needle and the following .unfound .pos
        for (self.haystack) |*arg, i| {
            if (arg.options.action != .pos) continue;
            self.haystack.len = i;
            break;
        }
    }
};

//----------//
// Argument //
//----------//

const TRUE = "TRUE";
const FALSE = "FALSE";

pub const ArgumentError = error{
    NotValidChoice,
    AlreadyFull,
    MissingResults,
    ArgCannotExtend,
    CompletionFailed,
};

pub const ArgumentOptions = struct {

    /// Argument behaviour.
    /// Arguments is always associated with an action. The action specifies
    /// how items (string input by user) are collected and handled by the
    /// `Argument` object.
    pub const Action = enum {
        /// Positional arguments.
        /// Usage:
        ///     exe a1 a2 a3 ... => [a1, a2, a3]
        /// Options:
        ///     nargs
        ///     required
        ///     choices
        pos,

        /// Traditional flag/option-like arguments.
        /// Usage:
        ///     exe -f a1 a2 ... aN => [a1, a2, ..., aN]
        /// Options:
        ///     nargs
        ///     extend
        ///     required
        ///     choices
        store,

        /// Store a specific constant.
        /// Usage:
        ///     exe -f => [c]
        /// Options:
        ///     extend
        store_const,

        /// Special case of `store_const` where result is true when argument is present.
        /// Usage:
        ///     exe -f => [1]
        store_true,

        /// Special case of `store_const` where result is false when argument is present.
        /// Usage:
        ///     exe -f => [0]
        store_false,

        // /// exe -fN
        // /// [N]
        // number,

        // /// exe -f -f -f
        // /// [3]
        // count,

        // /// exe a1 a2 P a3 a4 ...
        // /// parser(P, a3 a4 ...)
        // subparser,
    };

    //------------------//
    // Argument Options //
    //------------------//

    /// Generic name. Is not used to match the argument.
    name: ?Str = null,

    /// Short name of flag or option.
    short: ?Str = null,

    /// Long name of flag or option.
    long: ?Str = null,

    /// The type/behaviour of the argument.
    action: Action = .store,

    /// Number of arguments the argument can take.
    /// Can be supplied the following special case values:
    ///     '?' => One or none
    ///     '*' => None or many
    ///     '+' => One or many
    nargs: u8 = 1,

    /// Extendable/appendable argument. Can only be used with `action=.store` and `nargs>2`.
    extend: bool = false,

    /// The constant value for `store_const`. If the argument is present, this value will be the result.
    constant: ?Str = null,

    /// A default value for in case the argument is not present.
    default: ?Str = null,

    /// Require the argument to be present.
    required: bool = false,

    /// Limit what the result value can be. If the `choices` list is not empty, a value can then be
    /// accepted if it is found in the list.
    choices: ?[]Str = null,

    /// Can the argument be found only in the group it was defined, i.e. order-sensitive (.strict),
    /// or can it be found anywhere (.loose).
    location: enum { strict, loose } = .strict,

    /// A descriptive help message for the argument.
    help: ?Str = null,

    pub fn checkValidity(comptime self: ArgumentOptions) void {
        // action and names
        if (self.action == .pos and self.name == null)
            @compileError("Missing identifier - action `.pos` must have a `name`");
        if (self.action != .pos and self.short == null and self.long == null)
            @compileError("Missing identifier - action \"" ++ @tagName(self.action) ++ "\" must have either a `short` or `long` name");

        // names must have length
        if (self.name != null and self.name.?.len == 0)
            @compileError("Invalid identifier - `name` must be `null` of non-empty");
        if (self.short != null and self.short.?.len == 0)
            @compileError("Invalid identifier - `short` must be `null` of non-empty");
        if (self.long != null and self.long.?.len == 0)
            @compileError("Invalid identifier - `long` must be `null` of non-empty");

        // names and dashes
        if (self.short != null and self.short.?[0] == '-')
            @compileError("Invalid identifier - \"" ++ self.short.? ++ "\" dashes are inserted by the parser");
        if (self.long != null and self.long.?[0] == '-')
            @compileError("Invalid identifier - \"" ++ self.long.? ++ "\" dashes are inserted by the parser");

        // nargs
        if (self.nargs <= 0)
            @compileError("Invalid number of args - `nargs` must be greater than 0");
        if (self.required and self.nargs == '*')
            @compileError("Contradicting options - `nargs='*'` allows returning with `.empty` state while `required` does not");
        if (self.required and self.nargs == '?')
            @compileError("Contradicting options - `nargs='*'` allows returning with `.empty` state while `required` does not");

        // default
        if (self.required and self.default != null)
            @compileError("Contradicting options - `default` is used when returning with `.empty` state which is not allowed while `required`");
        if (self.nargs == '+' and self.default != null)
            @compileError("Contradicting options - `default` is used when returning with `.empty` state which is not allowed with `nargs='+'`");

        // constant
        if (self.action == .store and self.constant != null)
            @compileError("Contradicting options - action `store` picks up user-supplied values, not `constant`");
        if (self.action == .store_const and self.constant == null)
            @compileError("Must have constant - `constant` value must exist for action `.store_const`");
        if (self.action == .store_const and self.nargs > 1 and !self.extend)
            @compileError("Contradicting options - multiple `constant` must have `extend` enabled");

        // extend
        if (self.extend and self.action != .store)
            @compileError("Invalid combination - argument can `extend` only if also having action `.store`");
        if (self.extend and (self.nargs == '?' or self.nargs < 2))
            @compileError("Invalid combination - argument can `extend` if there is room for only one value.");

        // choices
        if (self.choices) |choices| {
            if (self.constant) |val| for (choices) |item| {
                if (item == val) break;
            } else @compileError("Constant not in choices - if `constant` is given it must comply with `choices`");

            if (self.default) |val| for (choices) |item| {
                if (item == val) break;
            } else @compileError("Default not in choices - if `default` is given it must comply with `choices`");
        }

        // location
        if (self.location == .loose and self.action == .pos)
            @compileError("Invalid combination - positional arguments must have `.strict` location.");
    }
};

pub const Argument = struct {
    const State = enum {
        unfound,
        empty,
        partial,
        full,
    };

    options: ArgumentOptions,
    allocator: Allocator,
    results: std.ArrayList(Str),
    state: State,

    pub fn init(allocator: Allocator, comptime opt: ArgumentOptions) Argument {
        opt.checkValidity();

        var self = Argument{
            .options = opt,
            .allocator = allocator,
            .results = std.ArrayList(Str).init(allocator),
            .state = .unfound,
        };

        if (self.options.nargs == '+')
            self.options.required = true;

        if (self.options.action == .store_true) {
            self.options.action = .store_const;
            self.options.constant = TRUE;
            self.options.default = FALSE;
        }

        if (self.options.action == .store_false) {
            self.options.action = .store_const;
            self.options.constant = TRUE;
            self.options.default = FALSE;
        }

        return self;
    }

    pub fn deinit(self: *Argument) void {
        for (self.results.items) |str|
            self.allocator.free(str);
        self.results.deinit();
    }

    pub fn isName(self: *Argument, item: Str) bool {
        var eql_cond: bool = false;
        if (self.options.name) |name|
            eql_cond = eql_cond or std.mem.eql(u8, item, name);
        if (self.options.short) |name|
            eql_cond = eql_cond or std.mem.eql(u8, item, name);
        if (self.options.long) |name|
            eql_cond = eql_cond or std.mem.eql(u8, item, name);
        return eql_cond;
    }

    pub fn isMatch(self: *Argument, item: Str) bool {
        if (std.mem.startsWith(u8, item, "--"))
            return if (self.options.long) |name| std.mem.eql(u8, name, item[2..]) else false;
        if (std.mem.startsWith(u8, item, "-"))
            return if (self.options.short) |name| std.mem.eql(u8, name, item[1..]) else false;
        return false;
    }

    pub fn isPartialLong(self: *Argument, item: Str) bool {
        return if (self.options.long) |name|
            std.mem.startsWith(u8, item, "--") and std.mem.startsWith(u8, name, item[2..])
        else
            false;
    }

    pub fn isPartialShort(self: *Argument, item: Str) bool {
        return if (self.options.short) |name|
            std.mem.startsWith(u8, item, "-") and std.mem.startsWith(u8, name, item[1..])
        else
            false;
    }

    pub fn found(self: *Argument, item: Str) (Allocator.Error || ArgumentError)!void {
        if (self.state == .unfound)
            self.state = .empty
        else if (!self.options.extend)
            return ArgumentError.ArgCannotExtend;

        switch (self.options.action) {
            .pos => try self.addResult(item),
            .store_const => try self.dupeAndAdd(self.options.constant.?),
            else => {},
        }
    }

    pub fn capacity(self: *Argument) usize {
        return switch (self.options.nargs) {
            '*', '+' => |n| n,
            '?' => 1 - self.results.items.len,
            else => |n| n - self.results.items.len,
        };
    }

    fn dupeAndAdd(self: *Argument, item: Str) (Allocator.Error || ArgumentError)!void {
        var copy = try self.allocator.dupe(u8, item);
        try self.addResult(copy);
    }

    // NOTE: Takes ownership of `item`.
    pub fn addResult(self: *Argument, item: Str) (Allocator.Error || ArgumentError)!void {
        self.state = switch (self.state) {
            .unfound => unreachable,
            .empty, .partial => switch (self.options.nargs) {
                '*', '+' => State.partial,
                '?' => State.full,
                else => |n| if (self.results.items.len + 1 < n) State.partial else State.full,
            },
            .full => return ArgumentError.AlreadyFull,
        };

        if (self.options.choices) |choices| for (choices) |choice| {
            if (std.mem.eql(u8, item, choice))
                break;
        } else return ArgumentError.NotValidChoice;

        try self.results.append(item);
    }

    pub fn finally(self: *Argument) (Allocator.Error || ArgumentError)!void {
        switch (self.state) {
            .unfound => if (self.options.default) |val| {
                self.state = .empty;
                try self.dupeAndAdd(val);
                try self.finally();
            },
            // .empty if e.g. `action=.store` and `nargs='*'` with flag present but no arguments.
            // .empty does not get default value, default value is only given if unfound.
            .empty => switch (self.options.nargs) {
                '*', '?' => {},
                '+' => return ArgumentError.MissingResults,
                else => return ArgumentError.MissingResults,
            },
            .partial => switch (self.options.nargs) {
                '*', '?', '+' => {},
                else => |n| {
                    if (self.results.items.len < n)
                        return ArgumentError.MissingResults;
                },
            },
            .full => {},
        }
    }

    const GetResultOptions = struct {
        comptime Type: type = Str,
        index: usize = 0,
    };

    const GetResultErrors = error{
        IndexOutOfBounds,
        NotBoolean,
    };

    /// Get a result from the parser.
    pub fn getResult(self: *Argument, comptime opt: GetResultOptions) !opt.Type {
        switch (self.options.nargs) {
            '*' => {},
            '?' => if (1 < opt.index) return GetResultErrors.IndexOutOfBounds,
            '+' => if (opt.index == 0) return GetResultErrors.IndexOutOfBounds,
            else => |n| if (n <= opt.index) return GetResultErrors.IndexOutOfBounds,
        }
        if (self.results.items.len <= opt.index)
            return GetResultErrors.IndexOutOfBounds;

        switch (@typeInfo(opt.Type)) {
            .Int => |t| switch (t.signedness) {
                .signed => try std.fmt.parseInt(opt.Type, self.results.items[opt.index], 0),
                .unsigned => try std.fmt.parseUnsigned(opt.Type, self.results.items[opt.index], 0),
            },
            .Bool => {
                if (self.results.items[opt.index].len == TRUE.len)
                    for (self.results.items[opt.index]) |c, i| {
                        if (std.ascii.toUpper(c) != TRUE[i]) break;
                    } else return true;

                if (self.results.items[opt.index].len == FALSE.len)
                    for (self.results.items[opt.index]) |c, i| {
                        if (std.ascii.toUpper(c) != FALSE[i]) break;
                    } else return false;

                return GetResultErrors.NotBoolean;
            },
            .Pointer => |t| {
                if (t.size != .Slice) @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
                if (t.child != u8) @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
                if (!t.is_const) @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
                return if (t.sentinel == null)
                    self.results.items[opt.index]
                else if (t.sentinel == 0)
                    self.results.items[opt.index][0.. :0]
                else
                    @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\". Perhaps: []const u8");
            },
            else => @compileError("Invalid type \"" ++ @typeName(opt.Type) ++ "\"."),
        }
    }
};

//------------//
// Completion //
//------------//

// TODO: See ~/playground/my-argparse-app
pub fn bashCompletion(parser: Parser, _: struct {}) !void {
    const writer = std.io.getStdOut().writer();

    const comp_line = std.os.getenv("COMP_LINE") orelse return; // The current command line.
    _ = std.os.getenv("COMP_POINT") orelse return; // The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to ${#COMP_LINE}.
    const comp_type = std.os.getenv("COMP_TYPE") orelse return; // Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called. See switch statement below.
    _ = std.os.getenv("COMP_KEY") orelse return; // The key (or final key of a key sequence) used to invoke the current completion function.

    // var inner_parser = ArgumentParser.Inner(@Type(words)).init(parser, &words);
    // std.log.info("\"{s}\"", .{comp_line});

    var words = std.mem.tokenize(u8, comp_line, " ");
    var last_word: []const u8 = undefined;
    while (words.next()) |item|
        last_word = item;

    _ = comp_line;
    _ = comp_type;
    _ = parser;
    _ = writer;

    // TAB, for normal completion
    // ‘?’, for listing completions after successive tabs
    // ‘!’, for listing alternatives on partial word completion
    // ‘@’, to list completions if the word is not unmodified
    // ‘%’, for menu completion
    switch (try std.fmt.parseUnsigned(u8, comp_type, 10)) {
        '\t' => for (parser.arguments.items) |*arg| {
            if (std.mem.eql(u8, "-", last_word)) {
                if (arg.options.short) |name| try writer.print("-{s}\n", .{name});
                if (arg.options.long) |name| try writer.print("--{s}\n", .{name});
            } else if (arg.isPartialShort(last_word)) {
                try writer.print("-{s}\n", .{arg.options.short.?});
            } else if (arg.isPartialLong(last_word)) {
                try writer.print("--{s}\n", .{arg.options.long.?});
            }
        },
        '?' => for (parser.arguments.items) |*arg| {
            if (arg.options.short != null and arg.options.long != null) {
                try writer.print("-{s}/--{s}\n", .{ arg.options.short.?, arg.options.long.? });
            } else if (arg.options.short) |name| {
                try writer.print("-{s}\n", .{name});
            } else if (arg.options.long) |name| {
                try writer.print("-{s}\n", .{name});
            }
        },
        '!', '@', '%' => |c| std.log.err("Not implemented yet - COMP_TYPE='{c}'", .{c}),
        else => |c| std.log.err("Invalid COMP_TYPE='{c}'", .{c}),
    }
}

//-----------------//
// Print utilities //
//-----------------//

fn FnPtrType(comptime T: type) type {
    return switch (@import("builtin").zig_backend) {
        .stage1 => T,
        else => *const T,
    };
}

pub fn formatRepr(
    bytes: Str,
    fmt: enum { upper, angle, short, long },
    writer: FileWriter,
) FileWriter.Error!void {
    switch (fmt) {
        .upper => for (bytes) |c| try writer.writeByte(std.ascii.toUpper(c)),
        .angle => try writer.print("<{s}>", .{bytes}),
        .short => try writer.print("-{s}", .{bytes}),
        .long => try writer.print("--{s}", .{bytes}),
    }
}

const FormatUsageFn = FnPtrType(fn (*Parser, FileWriter) FileWriter.Error!void);

pub fn formatUsageX1(parser: *Parser, writer: FileWriter) FileWriter.Error!void {
    var group = Group.init(parser.arguments.items);

    try writer.writeAll("usage: ");
    while (group.ready) : (group.next()) {
        // print the positional
        if (group.needle.options.name) |name|
            try formatRepr(name, .angle, writer)
        else
            std.debug.print("arg={s}", .{group.needle});

        if (group.haystack.len > 0) {
            // print trunc shorts
            var short_printed = false;
            for (group.haystack) |*arg| if (arg.options.short) |name| {
                if (!short_printed) try writer.writeAll(" [-");
                try writer.writeAll(name);
                short_printed = true;
            };
            if (short_printed) try writer.writeByte(']');
            // print longs (and shorts if no trunc)
            for (group.haystack) |*arg| if (arg.options.long) |name| {
                if (arg.options.short == null)
                    try writer.print(" [--{s}]", .{name});
            };
        }
    }
    try writer.writeByte('\n');
}

const FormatHelpFn = FnPtrType(fn (*Parser, FileWriter) FileWriter.Error!void);

pub fn formatHelpX1(parser: *Parser, writer: FileWriter) FileWriter.Error!void {
    if (parser.options.fmtUsageFn) |fmtUsage|
        try fmtUsage(parser, writer);

    // positional
    for (parser.arguments.items) |*arg|
        if (arg.options.action == .pos) {};

    // other
    for (parser.arguments.items) |*arg|
        if (arg.options.action != .pos) {};
}

const FormatErrorFn = FnPtrType(fn (*Parser, (ParserError || ArgumentError), FileWriter) FileWriter.Error!void);

pub fn formatErrorX1(parser: *Parser, err: (ParserError || ArgumentError), writer: FileWriter) FileWriter.Error!void {
    switch (err) {
        // ParserError.NameCollision => {},
        // ParserError.OutOfArguments => {},
        ParserError.ItemNotRecognized => {
            try writer.print("error({s}): Item \"{s}\" not recognized.\n", .{ @errorName(err), parser.item });
        },
        // ParserError.NoSuchArgument => {},
        // ParserError.NotValidChoice => {},
        // ArgumentError.AlreadyFull => {},
        // ArgumentError.MissingResults => {},
        // ArgumentError.ArgCannotExtend => {},
        // ArgumentError.CompletionFailed => {},
        else => @panic("Not implemented message for current error"),
    }
}

//--------------------//
// Iterator Utilities //
//--------------------//

fn SliceIterator(comptime T: type) type {
    return struct {
        index: usize,
        slice: []const T,

        const Self = @This();

        pub fn init(slice: []const T) Self {
            return Self{ .index = 0, .slice = slice };
        }

        pub fn next(self: *Self) ?T {
            if (self.slice.len <= self.index)
                return null;
            defer self.index += 1;
            return self.slice[self.index];
        }
    };
}

pub fn ArgvIterator(comptime argv: anytype) type {
    const ArgvType = @TypeOf(argv);
    const argv_fields = std.meta.fields(ArgvType);

    if (@typeInfo(ArgvType) != .Struct)
        @compileError("Expected tuple argument, found " ++ @typeName(ArgvType));

    comptime var arr: [argv_fields.len]StrZ = undefined;
    inline for (argv_fields) |field, i|
        arr[i] = @field(argv, field.name);

    return struct {
        index: usize,
        argv: [arr.len]StrZ,

        pub const Self = @This();

        pub fn init() Self {
            return Self{ .index = 0, .argv = argv };
        }

        pub fn next(self: *Self, allocator: std.mem.Allocator) !?StrZ {
            if (self.index < self.argv.len) {
                defer self.index += 1;
                return try allocator.dupeZ(u8, self.argv[self.index]);
            } else return null;
        }
    };
}
